}
download_rc_dataframe <- function(rcon, fields = NULL, events = NULL, study = "s3"){
# Make REDCap API call. Clean subject IDs according to study indication. If study = NULL,
# no cleaning will take place.
df <- exportRecords(rcon, fields = c("screen_id", fields), labels = FALSE, survey = FALSE,
dag = TRUE, events = events, form_complete_auto = FALSE,
dates = FALSE, factors = FALSE)
df <- df %>%
filter(!grepl("-2", df$screen_id) & nchar(screen_id) == 6)
if (study == "s3"){
df %>% filter(
grepl("X-", df$screen_id) |
grepl("Y-", df$screen_id) |
grepl("Z-", df$screen_id)
)
} else if (study == "s2") {
df %>% filter(
grepl("J-", df$screen_id) |
grepl("K-", df$screen_id) |
grepl("L-", df$screen_id)
)
} else {
df
}
}
pjt_ste <- function(df){
# impose project and site values on a data frame
pjt <- substr(df$screen_id, 1, 1)
ste <- substr(df$screen_id, 3, 3)
df$project <- NA
df$project[pjt == "X" | pjt == "J"] <- "Project 1"
df$project[pjt == "Y" | pjt == "K"] <- "Project 2"
df$project[pjt == "Z" | pjt == "L"] <- "Project 3"
df$site <- NA
df$site[ste == "A"] <- "uvm"
df$site[ste == "B"] <- "brown"
df$site[ste == "C"] <- "jhu"
df$site <- factor(df$site, levels = c("uvm", "brown", "jhu"))
return(df)
}
pi_prop <- function(df) {
# impose pilot/proper designation on a data frame
df$pi_prop <- ifelse(substr(df$screen_id, 4, 4) == 9, "pilot", "proper")
df
}
pull_status <- function(rcon) {
# return tidy data frame from the TCORS Study 3 "session log" enrollment
# status
fields <- c("sl_status", "is2_date")
events <- c("screening_arm_1", "baseline_2_arm_1")
df <- download_rc_dataframe(rcon, fields = fields, events = events)
df %>%
group_by(screen_id) %>%
tidyr::fill(is2_date, .direction = "updown") %>%
filter(redcap_event_name == "screening_arm_1") %>%
mutate(
baseline2_date = as.Date(is2_date),
sl_status = redcapFactorFlip(sl_status)
) %>%
pjt_ste() %>%
pi_prop() %>%
select(screen_id, sl_status, baseline2_date, project, site, pi_prop) %>%
ungroup()
}
download_ps <- function(rcon, fields = NULL, events = NULL) {
# Make REDCap API call to recruitment projects.
exportRecords(
rcon, fields = fields, labels = FALSE, survey = FALSE,
dag = TRUE, events = events, form_complete_auto = FALSE,
factors = FALSE
)
}
clean_ps <- function(ps_df, start_date = as.Date("2019-8-01")) {
# Filter out pre-screen records flagged as duplicate, error, or
# having a date outside of the acceptable range.
filter_str <- "-|_|copy|incomplete|empty|TEST|test"
ps_df %>%
filter(
!stringr::str_detect(redcap_id, filter_str),
!is.na(recruit_date),
as.Date(recruit_date) > start_date
)
}
ps_share <- function(df_id, df_ps) {
# merge identifying information with pre-screen data
id <- df_id
# arrange to spec
df_ps_sub <- df_ps %>%
select(-c(redcap_data_access_group, redcap_event_name))
df <- left_join(df_ps_sub, id, by = c("recruit_identinfo_id" = "online_id"))
df <- df %>%
filter(!redcap_id %in% "test") %>%
select(-c(recruit_identinfo_id))
df$recruit_date <- as.Date(df$recruit_date)
return(df)
}
download_ps_data <- function() {
# Produce merged pre-screen dataframe
rcon_ps <- build_rcon("rc_prescreen_uvm")
rcon_id <- build_rcon("rc_id_info_uvm")
ps_fields <- NULL
id_fields <- c(
"online_id", "fname_id", "lname_id", "address_id", "city_id", "state_id",
"zip_id", "phone_id", "email_id"
)
df_ps <- download_ps(rcon_ps, fields = ps_fields, NULL)
df_id <- download_ps(rcon_id, fields = id_fields, NULL)
df_ps <- clean_ps(df_ps)
ps_share(df_id, df_ps)
}
rename_matrix <- function(df) {
# make values names of columns
w1 <- which(df[,1:ncol(df)] == 1, arr.ind = TRUE)
w0 <- which(df[,1:ncol(df)] == 0, arr.ind = TRUE)
# avoid zero-length error
if(length(w1 > 0)) {
df[w1] <- names(df)[w1[,"col"]]
}
df[w0] <- NA
df
}
reshape_matrix <- function(df, rename_list, colname, prefix, rename = TRUE) {
if (rename) {
df_sub <- df %>%
plyr::rename(rename_list)
} else {
df_sub <- df
}
df_sub <- df_sub %>%
select(unlist(rename_list, use.names = FALSE)) %>%
rename_matrix() %>%
tidyr::unite(
col = !!colname,
sep = ",",
na.rm = TRUE
)
df_sub[df_sub == ""] <- NA
df %>%
select(-starts_with(prefix)) %>%
cbind(df_sub)
}
recode_flyer <- function(df) {
# participants often confuse "flyer" with "direct_mail." recode
# any flyer_location that suggests direct mailing
pattern <- "mail|mailbox|home|house"
df %>%
mutate(
recruit_1___10 = ifelse(
!is.na(recruit_1b) &
stringr::str_detect(tolower(recruit_1b), pattern),
1, recruit_1___10
),
recruit_1___4 = ifelse(
!is.na(recruit_1b) &
stringr::str_detect(tolower(recruit_1b), pattern),
0, recruit_1___4
)
)
}
detect_exclusion <- function(df_sub, excl_list) {
df_sub %>%
mutate(
gen_excluded = purrr::map(
reasons_for_exclusion,
stringr::str_detect,
pattern = excl_list
),
gen_excluded = purrr::map_lgl(
gen_excluded,
~ifelse(TRUE %in% .x, TRUE, FALSE)
)
)
}
gather_ps_data <- function(df, rct_source_vars, excl_vector) {
# sources
df_source <- df %>%
recode_flyer() %>%
reshape_matrix(
rct_source_vars,
"recruitment_sources",
"recruit_1_"
) %>%
select(recruitment_sources)
# exclusion
df_exclusion <- df %>%
plyr::rename(excl_vector) %>%
dplyr::mutate(
not_smoking_daily = ifelse(not_smoking_daily == 1, 1, 0),
low_cpd = ifelse(low_cpd <= 5, 1, 0),
daily_ecig_use = ifelse(daily_ecig_use >= 6, 1, 0),
other_tobacco_30days = ifelse(other_tobacco_30days > 9, 1, 0),
age = ifelse(age < 21 | age > 70, 1, 0),
male = ifelse(male == 0, 1, 0),
gender_identity = ifelse(gender_identity != 1, 1, 0),
education_level = ifelse(education_level > 4, 1, 0),
not_receiving_MAT = ifelse(not_receiving_MAT == 0, 1, 0),
gad_score = ifelse(gad_score < 3, 1, 0),
phq_score = ifelse(phq_score < 3, 1, 0),
gest_age = ifelse(gest_age > 26, 1, 0),
age_p1_p4 = ifelse(age > 44, 1, 0),
not_pregnant = ifelse(not_pregnant == 0, 1, 0)
) %>%
reshape_matrix(
excl_vector,
"reasons_for_exclusion",
"recruit_",
rename = FALSE
) %>%
mutate(reasons_for_exclusion = ifelse(
elig_project_none > 0,
reasons_for_exclusion,
NA
)) %>%
select(reasons_for_exclusion)
df_out <- df %>%
select(
redcap_id,
recruit_date,
recruit_int_summ,
screen_status,
screen_subjectid,
zip_id,
elig_project_1,
elig_project_2,
elig_project_3,
elig_project_4,
elig_project_none
) %>%
cbind(df_source) %>%
cbind(df_exclusion)
df_out %>%
detect_exclusion(unlist(excl_vector[1], use.names = FALSE))
}
# gather_ps_data <- function(ps_data) {
#   # return a list of prescreen zip codes, project eligible, and whether
#   # they attended in-person screening
#
#   # clean and recode
#   ps_data <- ps_data %>%
#     filter(!is.na(recruit_date)) %>%
#     rename(flyer_location = recruit_1b) %>%
#     mutate(
#       ps_proj_eligible = ifelse(elig_project_none == 1, "ineligible", NA),
#       ps_proj_eligible = ifelse(elig_project_2 == 1, "Project 2", ps_proj_eligible),
#       ps_proj_eligible = ifelse(elig_project_4 == 1, "Project 4", ps_proj_eligible),
#       ps_proj_eligible = ifelse(
#         elig_project_1 == 1 &
#           elig_project_3 == 1,
#         "Project 1 and Project 3",
#         ps_proj_eligible
#       ),
#       ps_proj_eligible = ifelse(
#         is.na(ps_proj_eligible) &
#           elig_project_1 == 1,
#         "Project 1",
#         ps_proj_eligible
#       ),
#       ps_proj_eligible = ifelse(
#         is.na(ps_proj_eligible) &
#           elig_project_3 == 1,
#         "Project 3",
#         ps_proj_eligible
#       ),
#       screened = ifelse(!is.na(screen_subjectid), "yes", "no"),
#       state_id = redcapFactorFlip(state_id),
#       num_sources = rowSums(across(starts_with("recruit_1")))
#     ) %>%
#     select(-c(
#       elig_project_1,
#       elig_project_2,
#       elig_project_3,
#       elig_project_4,
#       elig_project_none,
#       redcap_data_access_group,
#       email_id,
#       phone_id,
#       address_id,
#       fname_id,
#       lname_id
#     ))
#
#   more_than_one <- ps_data %>%
#     filter(num_sources > 1) %>%
#     mutate(source = ifelse(recruit_1___20 == 1, "BuildClinical", "multiple")) %>%
#     select(-starts_with("recruit_1"))
#
#
#   only_one <- ps_data %>%
#     filter(num_sources == 1)
#
#   only_one <- rename_source(only_one, n_val = 9)
#
#   # manual replace list:
#
#   only_one <- only_one %>%
#     mutate(zip_id = recode(zip_id,
#       "05852" = "05851",
#       "05402" = "05401",
#       "05246" = "05346",
#       "05378" = "05478",
#       "05467" = "05408",
#       "05856" = "05647",
#       "04503" = "05403",
#       "05402" = "05452",
#       "05750" = "05735",
#       "05462" = "05461",
#       "05671" = "05661"
#     ))
#
#   list(only_one, more_than_one)
# }
join_crosswalk <- function(ps_sub) {
ps_sub %>%
mutate(zip_id = as.numeric(zip_id)) %>%
left_join(
read.csv("./data/zipcodes.csv", stringsAsFactors = FALSE),
by = c("zip_id" = "ZIP")
)
}
recode_buildclinical <- function(ps_sub, start_date = as.Date("2021-10-22")) {
# BuildClinical took over digital recruitment for the TCORS
# main trial on 10/22/2021
pattern <- "facebook|instagram|google"
ps_sub %>%
mutate(
recruitment_sources = ifelse(
as.Date(recruit_date) >= start_date,
stringr::str_replace(
recruitment_sources,
pattern,
"BuildClinical"
),
recruitment_sources
)
)
}
merge_trial_data <- function(ps_location) {
status <- pull_status(build_rcon("rc_proper"))
ps_location %>%
left_join(status, by = c("screen_subjectid" = "screen_id")) %>%
mutate(
randomized = ifelse(!is.na(baseline2_date), "randomized", "not randomized"),
complete = ifelse(sl_status == "Complete", "complete", "not complete"),
complete = ifelse(is.na(complete), "not complete", complete),
screened = ifelse(!is.na(screen_subjectid), "screened", "not screened"),
recruit_int_summ = recode(
recruit_int_summ,
"1" = "screening_scheduled",
"2" = "waiting_list",
"3" = "screening_declined",
"4" = "ineligible",
"5" = "lost_contact",
.default = NA_character_
),
# recruit_int_summ = ifelse(
#   ps_proj_eligible == "ineligible",
#   "ineligible",
#   recruit_int_summ
#   ),
screen_status = recode(
screen_status,
"1" = "declined_consent",
"2" = "no-show",
"3" = "screened",
.default = NA_character_
),
rand_proj = ifelse(
randomized == "randomized",
paste("rand:", project),
randomized)
)
}
vectorize_final <- function(ps_location) {
ps_location %>%
mutate(
recruitment_sources = as.list(strsplit(recruitment_sources, ",")),
reasons_for_exclusion = as.list(strsplit(reasons_for_exclusion, ","))
)
}
# P4 functions -----------
# download_ps_p4 <- function() {
#   # Project 4's REDCap project is structured differently,
#   # which requires a different approach.
#
#   rcon_ps_p4 <- build_rcon("rc_prescreen_p4")
#   # rcon_id_p4 <- build_rcon("rd_id_info_p4")
#
#   ps_fields <- c(
#     "redcap_id", "recruit_identinfo_id", "recruit_date",
#     "recruit_int_summ", "recruit_1",
#     "recruit_3", "recruit_4", "recruit_4a", "recruit_5",
#     "recruit_6", "recruit_7", "recruit_7a", "recruit_8",
#     "recruit_9", "recruit_10", "recruit_11", "recruit_12",
#     "recruit_13", "recruit_14", "recruit_15"
#   )
#
#   df_ps <- download_ps(rcon_ps_p4, fields = ps_fields)
#
#   df_ps %>%
#     mutate(ps_proj_eligible = ifelse(
#       recruit_3 == 1 &
#         (recruit_4 == 0 |
#            (recruit_4 == 1 & recruit_4a < 10)) &
#         recruit_5 == 0 &
#         recruit_6 == 0 &
#         recruit_7a == 0 &
#         (recruit_8 == 0 | recruit_8 == 7777) &
#         recruit_9 == 0 &
#         recruit_10 == 0 &
#         (recruit_11 > 17 & recruit_11 < 45) &
#         recruit_12 == 1 &
#         recruit_13 == 1 &
#         recruit_14 < 26 &
#         recruit_15 %in% 1:4,
#       "Project 4", "ineligible"
#     ),
#     recruit_int_summ = recode(
#       as.character(recruit_int_summ),
#       "1" = "screening_scheduled",
#       "2" = "waiting_list",
#       "3" = "screening_declined",
#       "4" = "ineligible",
#       "5" = "lost_contact",
#       .default = NA_character_
#     )
#     ) %>%
#     select(
#       redcap_id, recruit_identinfo_id, recruit_date,
#        recruit_int_summ, ps_proj_eligible, starts_with("recruit_1___")
#     )
# }
#
#
# gather_p4 <- function(p4_data) {
#   df <- p4_data %>%
#     mutate(num_sources = rowSums(across(starts_with("recruit_1")), na.rm = TRUE))
#
#   only_one <- df %>%
#     filter(num_sources == 1) %>%
#     select(-recruit_int_summ, recruit_int_summ)
#
#   only_one <- rename_source(only_one, n_val = 2)
#
#   more_than_one <- df %>%
#     filter(num_sources > 1) %>%
#     select(!starts_with("recruit_1___"))
#   more_than_one$source <- "multiple"
#
#   rbind(only_one, more_than_one)
# }
# main -----
ps_data <- download_ps_data() # API call
# ps_data <- ps_data %>% recode_facebook(as.Date("2021-10-22"), Sys.Date())
ps_sub <- gather_ps_data(
ps_data,
rct_source_vars,
excl_vector
)
ps_sub <- recode_buildclinical(ps_sub)
ps_location <- join_crosswalk(ps_sub)
# ps_sub_one <- p[[1]]
# ps_sub_multi <- p[[2]]
#
# ps_sub <- rbind(ps_sub_one, ps_sub_multi)
#
# did_not_merge <- ps_location %>%
#   filter(is.na(LAT) & !is.na(zip_id)) %>%
#   select(recruit_date, ps_proj_eligible, source, screened, zip_id, city_id, state_id)
# impose trial data
ps_location <- merge_trial_data(ps_location)
# vectorize
ps_location <- vectorize_final(ps_location)
# TODO Lay this out so we can pick a timeframe, look at sources, find reasons for ineligiblity, and rates of everything
# write to disk
# write.csv(ps_location, "./out/ps_locations.csv", row.names = FALSE)
# write.csv(did_not_merge, "./out/no_location_data.csv", row.names = FALSE)
# write.csv(plot_df, "./out/plot_df.csv", row.names = FALSE)
save(ps_location, file = "./out/ps_locations.RData")
# timestamp
write.table(Sys.Date(), "./out/lastupdate.txt", row.names = FALSE, col.names = FALSE)
runApp()
runApp()
runApp()
runApp()
runApp()
df_plot <- df %>%
mutate(
ps_eligible = factor(ifelse(
elig_project_none == 0, "eligible", "ineligible"
),
levels = c("ineligible", "eligible")))
df <- ps_location
df_plot <- df %>%
mutate(
ps_eligible = factor(ifelse(
elig_project_none == 0, "eligible", "ineligible"
),
levels = c("ineligible", "eligible")))
df
runApp()
df_plot <- df %>%
mutate(
ps_eligible = factor(ifelse(
elig_project_none == 0, "eligible", "ineligible"
),
levels = c("ineligible", "eligible")
)
) %>%
filter(!is.na(zip_id)) %>%
group_by(recruit_date, ps_eligible, zip = zip_id) %>%
count() %>%
left_join(load_mailer_ledger(), by = "zip")
